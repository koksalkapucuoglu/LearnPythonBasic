Gereklilikler
----------------
**sayfa containerını düzenle. oldu gibi + 
**kullanıcı adı veritabında varsa hata veriyor. + 
**admin paneline flowchartaki özellikleri ekle
**ticari kullanımlar için sayfa olustur
orta katman tamam, en üstteki yapı oluşturulacak
**aboutus sayfası oluştur
**profile sayfası oluştur

#walkovradmin/walkovr20162016
XAMPP indir, xampp kontrol panelinden apache ve mysql açtıktan sonra msql sırasındaki admin butonuna tıkla ve mysql databesesine eriş.
Burada "database" kısmına gelip bir database oluştur.(connectMysqlDemo). Bu database sol tarafa küçük harflerle eklenecek ama sen
ilerde kullanırken büyük küçük harfe dikkat et.

konsoldan , django-admin startproject "proje_adı" gir.
Bulunduğun dizinde bir proje klasörü oluşacak. Bu klasörde django projesi için gerekli olan temel dosyalar bulunuyor.

Django default olarak sqlite3 veritabanı ekli olarak geliyor. Mysql'e bağlamak için Settings.py/database kısmını aşağıdaki gibi değiştir.
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'connectMysqlDemo',
        'USER': 'root',
        'PASSWORD': '', 
        'HOST': 'localhost',
        'PORT': '3306',

    }
konsola "python manage.py runserver" yazarsanız proje çalışır. djano projesinde hazır olarak oluşturulmuş (settings/Installed Apps'de görülür) 
bir admin paneli uygulamaları vardır. Bu listeleri mysql'e atmak için "python manage migrate" komutunu çalıştırıyoruz.

Daha sonra databaseyi kontrol edersek tüm tabloların buraya eklendiğini göreceğiz. bundan sonra bu tablolarda bir değişiklik 
olduğunda veritabanı otomatik olarak güncellenir. 

Daha sonra "python manage.py createsuperuser" diyerek bir süper kullanıcı oluşturuyoruz. Bu kullanıcı ile "http://127.0.0.1:8000/admin/"e 
giriş yapabiliriz. Bu tablolarla mysql'i entegre ettiğimiz için bu admin panelinden yaptığımız her değişikliği mysql'de oluşturduğumuz 
görebiliriz.

Djangoda ORM yapısını kullanarak herhangi bir sql sorgusu kullanmadan veritabanı ile bağlantıya geçebiliyoruz.

2.terminali açtıktan sonra buraya python manage.py shell yazıyoruz ve çıkan ekrana aşağıdaki kodları tek tek yazarak orm yapısını anlamaya çalışıyoruz.

In [3]: from django.contrib.auth.models import User

In [4]: User
Out[4]: django.contrib.auth.models.User

newUser = User(username = "denemekullanici", password = "123") #newuser şeklinde bir obje oluşturuyoruz.

newUser.save() diyerek bu kullanıcıyı veritabanına kaydediyoruz. Daha sonra veritabanına bakabiliriz. Tabi burada şifreyi 
şifrelemediğimiz için veritabanında direkt 123 görüyoruz.

Passwordü şifreleyerek göndermek için dahil ettiğimiz kütüphanedeki hazır bir fonksiyonu kullanıyoruz.
In [9]: newUser2 = User(username = "denemekullanici2")

In [10]: newUser2.set_password("123")

burada set_password girdiğimiz şifreyi, şifreleyerek bir parola oluşturacak

Daha farklı özelliklerini eklemek için 

In [18]: newUser3 = User()

In [19]: newUser3.first_name = "walkovr"

In [20]: newUser3.username = "denemekullanici3"

In [21]: newUser3.set_password("123") yapıyoruz. 

veritabanında olan bir kullanıcıyı, User metodundan alıp görüntüleyebiliyoruz.
user = User.objects.get(username = "walkovradmin")
user.username
'walkovradmin'
user.mail
'koksal@walkovr.com'

Uygulama kavramı
Uygulama kavramı projeyi kaça ayırmak istiyorsak bunu simgeliyor.
python manage.py startapp panelapp ile bir app oluşturuyoruz.

DJANGO URL YAPISI
ilk önce settings.py/template kısmına gelip DIR kısmına html templatelerimizi nereye koyacağımızı belirteceğiz.
daha sonra templates diye bir klasör oluşturup ilk hmtl dosyamızı oluşturuyoruz.(index.html)
Bu klasörde ! işaretini yapıp tab dediğimizde genel yapı geliyor. Burada başlığı değiştirip ilk yapımızı oluşturuyoruz.
urls.py/urlpatterns altındaki kısma yeni bir path ekleriz. 
 path('', admin.site.urls), #localhost:8000 'i eklediğimizde localhost8000 sayfasında '' fonksiyonuna gider. Bunu fonksiyonu oluşturduğumuz 
 uygulama altındaki views.py dosyasıdan tanımlarız.
 def index(request):
    pass

django kendisi otomatik olarak o istek doğrultusundan belli bilgileri taşıyan request değişkenini gönderiyor. request her view fonksiyonunda 
ilk parametre olarak tanımlanmalı.
def index(request):
    return HttpResponse("<h3>HOME</h3>")#bu fonksiyonla http response dönebiliriz.

Sonra urls sayfasına gidip aşağıdaki kütüphaneyi ekliyoruz ve artık '' pathinde admin.site.urls yerine index içine gitsin diyoruz.

from panelapp.views import index #views içinde olusturdugumuz index fonksiyonunu cagiriyoruz.
path('', index), #localhost:8000

istersek bu view'dan bir template de dönebiliriz.

def index(request):
    return render(request,"index.html",name = "index") #template dönmek için bu şekilde bir return yazarız.
    #return HttpResponse("<h3>HOME</h3>")#bu fonksiyonla http response dönebiliriz.

Static dosyalar
uygulama sayfası altında bir static klasörü oluşturup altına style.css dosyası ekliyoruz. Daha sonra index.html dosyasından bu dosyayı
çağırıyoruz.
<link rel="stylesheet" href="../static/style.css"> burada ard arda iki nokta bir üste çıkmak için.
STATICFILES_DIRS = (
     os.path.join(BASE_DIR, 'static'),
)
STATIC_ROOT = os.path.join(os.path.dirname(BASE_DIR), 'static')

STATIC_URL = '/static/'

static dosya yolu belirtme işi hata verirse yukarıdaki gibi olacak

layout.html dosyasından index.html'den inherit etmek
<div class="container">

        {% block body %} 
        {% endblock  %}
    </div>

    burada body'nin içini index.html kendisi dolduracak

index.html dosya içi
{% extends 'layout.html' %}

{% block  %}

<h3> Anasayfa </h3>

{% endblock  %}


'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'connectMysqlDemo',
        'USER': 'root',
        'PASSWORD': '', 
        'HOST': 'localhost',
        'PORT': '3306',
    }
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'test',
        'USER': 'walkovr-user',
        'PASSWORD': '3edcFT&baran', 
        'HOST': '167.172.234.213',
        'PORT': '3306',
    }
--------------------
python manage.py startapp content
daha sonra content/model.py dosyasına gelerek content uygulamasına uygun olarak bir tablo ve bu tabloya uygun olarak bir model olusturacagız
class Content(models.Model):
    #content uygulamasında kac alan olacaksa bunları girmek gerekiyor.
    id = models.AutoField(primary_key=True)
    #ilk olarak content sahibi, kullanıcı tanımlıyoruz.
    user = models.name = models.ForeignKey("auth.User", on_delete=models.CASCADE)
    #"auth.User" tablosundaki user direk buraya gelecek.
    playing_time = models.name = models.CharField(max_length=50) #Oturum Başına Ortalama Oynama Süresi(dk/session)
    session_count = models.name = models.CharField(max_length=50)#Toplam Oynama Süresi(dk)
    total_step = models.name = models.CharField(max_length=50)#Toplam Adım Sayısı(step)
    total_walk = models.name = models.CharField(max_length=50)#Toplam Yürüme Mesafesi(m)
    total_run = models.name = models.CharField(max_length=50)#Toplam Koşu Mesafesi(m)
    total_calori = models.name = models.CharField(max_length=50)# Yakılan Toplam Kalori(cal)

Daha sonra content/admin.py'ye girip bu verileri dashboardda göstermek için buraya kaydediyoruz.

from .models import Content
 # Register your models here.
admin.site.register(Content)

Daha sonra walkovr1/settings'te intalled apps kısmına content appimimizi yazıyoruz.
daha sonra siteyi tekrar başlatıp localhost8000/admin, admin paneline geldiğimizde burada content diye bir alan olustugunu görüyoruz.
fakat buna tıkladığımızda aşağıdaki hatayı alıyoruz.
(1146, "Table 'connectmysqldemo.content_content' doesn't exist")
bunun için 2 işlem yapmalıyız.İlk önce content/migrations altında tablolarımızı olusturmalıyız.
Bunun icin "makemigrations komutunu çalıstırmalıyız.
"python manage.py makemigrations" bu komut buradaki modele göre sql sorgusuna benzer bir dosya olusturacak
Migrations for 'content':
  content\migrations\0001_initial.py
    - Create model Content

ikinci olarak da ;
python manage.py migrate diyoruz. bu işlem buradaki migrations dosyasına göre bizim tablomuzu olusturacak.
Operations to perform:
  Apply all migrations: admin, auth, content, contenttypes, sessions
Running migrations:
  Applying content.0001_initial... OK

content/admin.py'de model admin clasından bir tane class türetmek istiyoruz.

grup ismine göre filtreleme
--------------
my_group_q = Group.objects.filter(name='grup name')
my_group = list(my_group_q) 
print("group name:",my_group[0].name)
print("group id:",my_group[0].id)
-------------------
"""
    #kullanıcının dahil oldugu tüm gruplar alıyor
    l=[]
    for g in request.user.groups.all():
        l.append(g.name)
    print(l)
"""
grup ismine göre kullancıları alma
print("*************************************")
    group = Group.objects.get(name = my_groups[0].name)
    users_q = group.user_set.all()
    users = list(users_q) 
    print(users)
    for user in users:
        print(user)
    
    print("*************************************")

    contents = Content.objects.filter(user = request.user) # user kullanıcısının bilgilerini aldık. 
    context = {
        "contents":contents
    }
    return render(request,"panel.html",context) 

    **********************************************
    user_id alma---------------------------------
    user_q = User.objects.filter(username = username)
        user = list(user_q)
        user_id = user[0].id
        print(user_id)
